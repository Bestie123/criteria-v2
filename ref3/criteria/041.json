{
  "id": "041",
  "text": "Unit тесты для изолированного тестирования компонентов: написание модульных тестов для каждой функции, класса и модуля, изоляция тестируемого кода от зависимостей через mocking и stubbing, использование AAA-паттерна (Arrange-Act-Assert) для структуры тестов, покрытие различных сценариев (happy path, edge cases, error cases), автоматический запуск тестов через test runner, интеграция с CI/CD для автоматического тестирования при коммитах, поддержание высокого test coverage (>80%), использование test frameworks (Jest, Mocha, Pytest, JUnit), параметризованные тесты для проверки множества входных данных, snapshot тесты для UI компонентов",
  "categories": [
    "ai-criteria",
    "processes",
    "quality"
  ],
  "tags": [
    "AAA-паттерн",
    "TDD",
    "mocking",
    "test coverage",
    "unit testing",
    "тесты"
  ],
  "categories_info": [
    {
      "key": "ai-criteria",
      "title": "Критерии для нейросети",
      "description": "Требования к интеграции ИИ-помощника"
    },
    {
      "key": "processes",
      "title": "Процессы разработки",
      "description": "Методологии и практики работы команды"
    },
    {
      "key": "quality",
      "title": "Требования к качеству",
      "description": "Нефункциональные требования и стандарты"
    }
  ],
  "contexts": {
    "quality": {
      "subcategories": [
        "Тестирование"
      ],
      "descriptions": {
        "Тестирование": "Требования к unit тестам для обеспечения качества кода: 1) Структура тестов - использование AAA-паттерна (Arrange-Act-Assert) для четкой организации тестов (Arrange - подготовка данных и настройка окружения, Act - выполнение тестируемого действия, Assert - проверка результатов), один тест проверяет одно поведение или сценарий, понятные имена тестов описывающие что тестируется и ожидаемый результат (например testCalculateTotalPrice_WithDiscount_ReturnsReducedPrice), группировка связанных тестов в test suites или describe блоки. 2) Изоляция тестов - каждый тест должен быть независимым и не зависеть от порядка выполнения других тестов, изоляция от внешних зависимостей (база данных, API, файловая система) через mocking и stubbing, использование test doubles (mocks, stubs, spies, fakes) для замены реальных зависимостей, очистка состояния после каждого теста (teardown) для предотвращения side effects. 3) Покрытие сценариев - happy path тесты для проверки нормального поведения с корректными входными данными, edge cases тесты для граничных значений (пустые массивы, null, undefined, максимальные/минимальные значения), error cases тесты для проверки обработки ошибок и исключительных ситуаций, negative tests для проверки что система корректно отклоняет некорректные данные. 4) Test coverage - поддержание высокого покрытия кода тестами (минимум 80%, критические компоненты 100%), измерение coverage через инструменты (Istanbul/nyc для JavaScript, Coverage.py для Python, JaCoCo для Java), покрытие всех веток кода (branch coverage) а не только строк (line coverage), приоритизация тестирования критических путей и бизнес-логики. 5) Test frameworks и инструменты - использование популярных test frameworks для языка проекта (Jest для JavaScript/TypeScript с встроенным mocking и snapshot testing, Mocha + Chai для гибкой настройки, Pytest для Python с fixtures и parametrize, JUnit для Java с annotations, RSpec для Ruby с BDD-style syntax), test runners для автоматического запуска тестов (npm test, pytest, mvn test), assertion libraries для выразительных проверок (expect, should, assert). 6) Параметризованные тесты - использование data-driven тестов для проверки множества входных данных с одним тестовым кодом, параметризация через test.each в Jest, @pytest.mark.parametrize в Pytest, @ParameterizedTest в JUnit, сокращение дублирования тестового кода при проверке похожих сценариев. 7) Snapshot тесты - использование snapshot testing для UI компонентов и сериализуемых структур данных, автоматическое сравнение текущего вывода с сохраненным snapshot, обновление snapshots при намеренных изменениях, ревью изменений snapshots в code review. 8) Performance тестов - unit тесты должны выполняться быстро (миллисекунды на тест) для частого запуска, избегание медленных операций (реальные HTTP запросы, работа с файлами, sleep), использование параллельного запуска тестов для ускорения, мониторинг времени выполнения тестов и оптимизация медленных. 9) Интеграция с CI/CD - автоматический запуск всех unit тестов при каждом коммите и pull request, блокировка merge при падении тестов, отчеты о test coverage в pull requests, уведомления о падении тестов"
      }
    },
    "ai-criteria": {
      "subcategories": [],
      "descriptions": {
        "null": "Использование ИИ-ассистента для генерации и улучшения unit тестов: 1) Автоматическая генерация тестов - генерация unit тестов для функций и классов на основе их сигнатуры и реализации, создание тестов покрывающих различные сценарии (happy path, edge cases, error cases) автоматически, генерация mock объектов для зависимостей, создание test fixtures и setup/teardown кода, генерация параметризованных тестов для проверки множества входных данных. 2) Анализ покрытия - анализ существующего test coverage и выявление непокрытых участков кода, предложение тестов для увеличения coverage критических компонентов, определение приоритетных областей для тестирования на основе сложности и важности кода, анализ branch coverage и предложение тестов для непокрытых веток. 3) Улучшение существующих тестов - рефакторинг тестов для улучшения читаемости и поддерживаемости, предложение более выразительных assertions, оптимизация медленных тестов, выявление дублирования в тестовом коде и предложение общих helper функций, улучшение изоляции тестов через правильное использование mocks и stubs. 4) Генерация test data - создание реалистичных тестовых данных для различных сценариев, генерация edge cases и граничных значений, создание mock данных соответствующих схеме API или базы данных, генерация больших наборов данных для параметризованных тестов. 5) Помощь в TDD (Test-Driven Development) - генерация failing тестов на основе требований перед написанием кода, предложение минимальной реализации для прохождения тестов, помощь в рефакторинге после прохождения тестов, генерация дополнительных тестов для новых edge cases. 6) Анализ качества тестов - проверка что тесты действительно тестируют нужное поведение а не implementation details, выявление хрупких тестов которые ломаются при рефакторинге, проверка что тесты независимы и не имеют side effects, анализ что assertions проверяют правильные условия. 7) Документация тестов - генерация описательных имен тестов, добавление комментариев объясняющих сложные тестовые сценарии, создание документации по запуску и отладке тестов, генерация примеров использования API на основе тестов"
      }
    },
    "processes": {
      "subcategories": [],
      "descriptions": {
        "null": "Процесс написания и поддержки unit тестов в цикле разработки: 1) Test-Driven Development (TDD) - написание failing теста перед реализацией функциональности (Red фаза), написание минимального кода для прохождения теста (Green фаза), рефакторинг кода с сохранением прохождения тестов (Refactor фаза), повторение цикла Red-Green-Refactor для каждой новой функциональности, преимущества TDD (лучший дизайн кода, высокое покрытие, документация через тесты, уверенность в рефакторинге). 2) Написание тестов параллельно с кодом - для каждой новой функции сразу писать unit тесты, тесты как живая документация поведения кода, проверка работоспособности кода через тесты до интеграции, раннее выявление проблем в дизайне через сложность написания тестов. 3) Запуск тестов - запуск всех unit тестов перед каждым коммитом для проверки что ничего не сломалось, использование watch mode для автоматического перезапуска тестов при изменении кода, запуск тестов в IDE для быстрой обратной связи, запуск полного test suite в CI/CD перед merge. 4) Поддержка тестов - обновление тестов при изменении требований или рефакторинге кода, удаление устаревших тестов для избыточной функциональности, рефакторинг тестов для улучшения читаемости и устранения дублирования, мониторинг времени выполнения тестов и оптимизация медленных, исправление flaky тестов которые периодически падают. 5) Code review тестов - проверка что новый код сопровождается тестами, ревью качества тестов (правильная изоляция, покрытие сценариев, читаемость), проверка что тесты действительно проверяют нужное поведение, валидация test coverage для критических изменений. 6) Метрики и мониторинг - отслеживание test coverage по модулям и компонентам, мониторинг количества падающих тестов, измерение времени выполнения test suite, анализ flaky тестов и их стабилизация, установка минимальных порогов coverage для проекта (например 80%). 7) Обучение команды - обучение best practices написания unit тестов, code review как способ обмена знаниями о тестировании, документирование паттернов и примеров хороших тестов, регулярные ретроспективы по улучшению процесса тестирования"
      }
    }
  }
}