{
  "id": "164",
  "text": "Комплексное руководство для разработчиков по полному циклу разработки: документ описывающий все этапы жизненного цикла разработки (планирование → проектирование → реализация → тестирование → деплой → поддержка), методологии разработки (Agile/Scrum/Kanban), роли и ответственность команды, процессы принятия архитектурных решений, определение критических компонентов (ядро, фундамент, несущие стены), best practices для каждого этапа, чеклисты и шаблоны для типовых задач, процессы код-ревью и тестирования, стратегии версионирования и релизов, процессы работы с ИИ-ассистентом на каждом этапе",
  "categories": [
    "ai-criteria",
    "processes",
    "quality"
  ],
  "tags": [
    "руководство",
    "цикл разработки",
    "SDLC",
    "методологии",
    "best practices",
    "workflow",
    "документация"
  ],
  "categories_info": [
    {
      "key": "ai-criteria",
      "title": "Критерии для нейросети",
      "description": "Требования к интеграции ИИ-помощника"
    },
    {
      "key": "processes",
      "title": "Процессы разработки",
      "description": "Методологии и практики работы команды"
    },
    {
      "key": "quality",
      "title": "Требования к качеству",
      "description": "Нефункциональные требования и стандарты"
    }
  ],
  "contexts": {
    "processes": {
      "subcategories": [
        "Работа с задачами"
      ],
      "descriptions": {
        "Работа с задачами": "Создать комплексное руководство описывающее полный жизненный цикл разработки (SDLC - Software Development Life Cycle): 1) Этап планирования - сбор и анализ требований (функциональные и нефункциональные требования, пользовательские истории, use cases), определение scope проекта и границ системы, оценка сложности и ресурсов, создание roadmap и разбиение на этапы/спринты, определение критических компонентов требующих особого внимания (ядро системы, фундаментальные модули, несущие стены архитектуры которые сложно изменить позже), приоритизация задач по важности и зависимостям, создание backlog с детализированными задачами. 2) Этап проектирования - выбор архитектурного подхода и паттернов (монолит, микросервисы, event-driven, layered architecture), проектирование структуры модулей и их взаимодействия, определение API и интерфейсов между компонентами, создание диаграмм архитектуры (C4 model, UML, sequence diagrams, data flow diagrams), проектирование схемы базы данных и моделей данных, определение технологического стека с обоснованием выбора, планирование точек расширения для будущего роста, документирование архитектурных решений и trade-offs. 3) Этап реализации - настройка окружения разработки и инфраструктуры, инкрементальная разработка с частыми проверками работоспособности, следование coding standards и style guides проекта, написание самодокументируемого кода с комментариями для сложной логики, использование систем контроля версий (Git) с осмысленными коммитами, регулярные code reviews для поддержания качества, рефакторинг для улучшения структуры без изменения поведения, документирование API и публичных интерфейсов. 4) Этап тестирования - написание unit тестов для изолированного тестирования компонентов, создание integration тестов для проверки взаимодействия модулей, end-to-end тесты для валидации пользовательских сценариев, performance тесты для проверки производительности под нагрузкой, security тесты для выявления уязвимостей, автоматизация тестирования через CI/CD пайплайны, поддержание высокого test coverage (>80%), регрессионное тестирование при изменениях. 5) Этап деплоя - подготовка production окружения и инфраструктуры, настройка CI/CD для автоматического деплоя, использование стратегий деплоя (blue-green, canary, rolling updates), настройка мониторинга и алертинга для отслеживания здоровья системы, подготовка rollback плана на случай проблем, документирование процесса деплоя и troubleshooting, проведение smoke тестов после деплоя. 6) Этап поддержки и развития - мониторинг метрик производительности и ошибок, быстрое реагирование на инциденты и баги, сбор обратной связи от пользователей, планирование улучшений и новых фич на основе feedback, регулярные обновления зависимостей и security патчи, документирование известных проблем и их решений, continuous improvement процессов разработки"
      }
    },
    "quality": {
      "subcategories": [
        "Документация"
      ],
      "descriptions": {
        "Документация": "Руководство должно включать детальную документацию по всем аспектам цикла разработки: 1) Методологии разработки - описание используемых методологий (Agile принципы гибкой разработки с итеративным подходом, Scrum framework с ролями Scrum Master/Product Owner/Development Team и церемониями Sprint Planning/Daily Standup/Sprint Review/Retrospective, Kanban для визуализации workflow с WIP limits и continuous delivery), выбор подходящей методологии в зависимости от типа проекта и команды, адаптация методологии под нужды проекта, метрики для измерения эффективности (velocity, cycle time, lead time). 2) Роли и ответственность - определение ролей в команде (Tech Lead отвечает за архитектурные решения и технический дизайн, Senior Developers проводят код-ревью и менторят junior разработчиков, QA Engineers отвечают за качество и тестирование, DevOps Engineers настраивают инфраструктуру и CI/CD, Product Owner определяет приоритеты и требования), матрица ответственности RACI (Responsible, Accountable, Consulted, Informed) для ключевых процессов, процессы эскалации проблем и принятия решений, коммуникационные каналы и встречи. 3) Best practices - coding standards (именование переменных и функций, структура файлов и модулей, комментирование кода, обработка ошибок), архитектурные принципы (SOLID, DRY, KISS, YAGNI, separation of concerns), паттерны проектирования для типовых задач, security best practices (валидация входных данных, защита от injection атак, безопасное хранение credentials), performance optimization techniques, accessibility guidelines для UI компонентов. 4) Чеклисты и шаблоны - чеклист для создания новой фичи (требования, дизайн, реализация, тесты, документация, ревью, деплой), шаблон для bug report с воспроизведением проблемы, шаблон для архитектурного решения (ADR - Architecture Decision Record), шаблон для код-ревью с критериями оценки, шаблон для post-mortem анализа инцидентов, шаблон для технической документации модуля. 5) Процессы код-ревью - цели код-ревью (поиск багов, улучшение качества кода, обмен знаниями, соблюдение стандартов), чеклист для ревьюера (корректность логики, читаемость кода, test coverage, производительность, безопасность, соответствие архитектуре), культура конструктивной критики, сроки проведения ревью, процесс разрешения разногласий. 6) Стратегии версионирования - semantic versioning (MAJOR.MINOR.PATCH), branching strategy (Git Flow, GitHub Flow, trunk-based development), процесс создания релизов, changelog и release notes, backward compatibility и deprecation policy, hotfix процесс для критических багов"
      }
    },
    "ai-criteria": {
      "subcategories": [],
      "descriptions": {
        "null": "Руководство должно описывать интеграцию ИИ-ассистента на каждом этапе цикла разработки: 1) Планирование с ИИ - использование ИИ для анализа требований и выявления неясностей, генерация user stories и acceptance criteria на основе описания фич, оценка сложности задач с помощью ИИ на основе исторических данных, предложение альтернативных подходов к реализации с анализом trade-offs, выявление потенциальных рисков и зависимостей между задачами, помощь в приоритизации через анализ бизнес-ценности и технической сложности. 2) Проектирование с ИИ - генерация вариантов архитектурных решений с обоснованием плюсов и минусов, создание диаграмм архитектуры (C4, UML, sequence diagrams) на основе описания, предложение подходящих паттернов проектирования для конкретных задач, анализ архитектуры на соответствие SOLID принципам и best practices, генерация API спецификаций (OpenAPI/Swagger) из описания, проверка архитектуры на потенциальные проблемы (циклические зависимости, tight coupling, single points of failure). 3) Реализация с ИИ - генерация boilerplate кода и структуры модулей по шаблонам, автодополнение кода с учетом контекста проекта, рефакторинг существующего кода с сохранением функциональности, генерация JSDoc/docstrings для функций и классов, помощь в отладке через анализ ошибок и stack traces, предложение оптимизаций производительности, проверка кода на соответствие проектным стандартам. 4) Тестирование с ИИ - генерация unit тестов для функций и классов, создание test cases для различных сценариев (happy path, edge cases, error cases), генерация mock данных для тестирования, анализ test coverage и предложение недостающих тестов, помощь в написании integration и e2e тестов, генерация performance тестов для нагрузочного тестирования. 5) Документация с ИИ - автоматическая генерация технической документации из кода, создание README и getting started guides, генерация API документации с примерами использования, создание архитектурных документов (ADR) из обсуждений, перевод документации на разные языки, поддержание актуальности документации при изменениях кода. 6) Код-ревью с ИИ - автоматический анализ кода на потенциальные баги и code smells, проверка соответствия coding standards и best practices, выявление security уязвимостей, анализ производительности и предложение оптимизаций, проверка test coverage и качества тестов, генерация конструктивных комментариев для ревью. 7) Техники эффективной работы с ИИ - использование структурированных промптов с точными путями к файлам и MODULE_ID/FUNC_ID, передача контекста через JSON для структурированных данных, декомпозиция сложных задач на атомарные части, итеративный подход с проверкой результатов на каждом шаге, использование шаблонов промптов для типовых задач, сохранение контекста между сессиями через документацию"
      }
    }
  }
}
