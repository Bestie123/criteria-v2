{
  "id": "166",
  "text": "Валидация и проверка ответов ИИ-ассистента: обязательная проверка всех ответов и сгенерированного кода от ИИ перед применением, проверка корректности понимания задачи через уточняющие вопросы, валидация соответствия требованиям и контексту проекта, проверка на галлюцинации ИИ (несуществующие API, библиотеки, функции), тестирование сгенерированного кода (компиляция, запуск, unit тесты), проверка соответствия проектным стандартам, валидация безопасности кода, проверка производительности решения, код-ревью как обычного кода, документирование найденных ошибок ИИ, использование чек-листа проверки ответов ИИ",
  "categories": [
    "ai-criteria",
    "processes",
    "quality"
  ],
  "tags": [
    "AI",
    "валидация",
    "галлюцинации",
    "код-ревью",
    "проверка",
    "тестирование"
  ],
  "categories_info": [
    {
      "key": "ai-criteria",
      "title": "Критерии для нейросети",
      "description": "Требования к интеграции ИИ-помощника"
    },
    {
      "key": "processes",
      "title": "Процессы разработки",
      "description": "Методологии и практики работы команды"
    },
    {
      "key": "quality",
      "title": "Требования к качеству",
      "description": "Нефункциональные требования и стандарты"
    }
  ],
  "contexts": {
    "ai-criteria": {
      "subcategories": [],
      "descriptions": {
        "null": "Требования к проверке ответов ИИ-ассистента: 1) Проверка понимания задачи - перед применением ответа ИИ убедиться что ИИ правильно понял задачу через уточняющие вопросы (Правильно ли я понял что нужно...?, Вы хотите чтобы я...?), проверка что ИИ учел весь контекст задачи (требования, ограничения, зависимости), валидация что ИИ не упустил важные детали из описания задачи, если ответ ИИ не соответствует ожиданиям - переформулировать запрос с дополнительными уточнениями, использование техники Chain-of-Thought для проверки логики рассуждений ИИ (попросить ИИ объяснить пошагово как он пришел к решению). 2) Проверка на галлюцинации - валидация что все упомянутые ИИ API, библиотеки, функции, методы действительно существуют (проверка в официальной документации), проверка что версии библиотек и синтаксис соответствуют текущему проекту, валидация что предложенные ИИ паттерны и подходы являются реальными best practices (не выдуманными), проверка что примеры кода от ИИ используют корректные импорты и зависимости, если ИИ ссылается на документацию или статьи - проверить что они существуют и актуальны, ведение списка типичных галлюцинаций ИИ для данного проекта для быстрой проверки. 3) Валидация соответствия контексту - проверка что решение ИИ соответствует архитектуре проекта (не нарушает принципы модульности, SOLID, DRY), валидация что код использует существующие модули и функции проекта (не дублирует функционал), проверка что решение совместимо с технологическим стеком проекта, валидация что ИИ учел существующие зависимости и ограничения, проверка что предложенное решение не конфликтует с другими частями системы, валидация что ИИ использовал правильные MODULE_ID, FUNC_ID, BLOCK_ID если они требуются. 4) Тестирование сгенерированного кода - компиляция/транспиляция кода для проверки синтаксических ошибок, запуск кода в изолированной среде для проверки runtime ошибок, написание и запуск unit тестов для проверки корректности логики, проверка edge cases и граничных условий, валидация обработки ошибок и исключений, проверка что код не ломает существующие тесты (регрессионное тестирование), использование линтеров и статических анализаторов для проверки качества кода. 5) Проверка безопасности - валидация что код не содержит уязвимостей (SQL injection, XSS, CSRF, path traversal), проверка что ИИ не предложил небезопасные практики (eval, innerHTML без санитизации, хранение паролей в plaintext), валидация что код правильно обрабатывает пользовательский ввод (валидация, санитизация, экранирование), проверка что ИИ не включил в код чувствительные данные (API ключи, пароли, токены), валидация прав доступа и авторизации в предложенном коде, использование security linters (ESLint security plugins, Snyk, SonarQube) для автоматической проверки. 6) Проверка производительности - валидация что решение ИИ не имеет очевидных проблем с производительностью (O(n²) вместо O(n), лишние циклы, неэффективные алгоритмы), проверка что код не создает утечки памяти (незакрытые соединения, неочищенные event listeners, циклические ссылки), валидация что ИИ использовал оптимальные структуры данных для задачи, проверка что нет избыточных вычислений или дублирования работы, бенчмаркинг критичных участков кода для проверки производительности, сравнение производительности решения ИИ с альтернативными подходами. 7) Документирование ошибок ИИ - ведение лога найденных ошибок и галлюцинаций ИИ с примерами, анализ паттернов ошибок для улучшения промптов, создание базы знаний типичных проблем ИИ для данного проекта, обновление промптов и инструкций для ИИ на основе найденных ошибок, sharing найденных проблем с командой для повышения осведомленности, использование найденных ошибок для обучения и калибровки ожиданий от ИИ"
      }
    },
    "processes": {
      "subcategories": [
        "Troubleshooting и отладка"
      ],
      "descriptions": {
        "Troubleshooting и отладка": "Процесс проверки ответов ИИ в workflow разработки: 1) Перед применением ответа - прочитать и понять предложенное ИИ решение полностью (не копировать слепо), проверить что решение отвечает на поставленный вопрос, задать уточняющие вопросы ИИ если что-то неясно, проверить упомянутые API и библиотеки в документации, валидировать что решение соответствует архитектуре проекта, оценить потенциальные риски и побочные эффекты решения. 2) При применении кода от ИИ - применять код небольшими частями с проверкой после каждой части, запускать линтеры и форматтеры на сгенерированном коде, компилировать/транспилировать код для проверки синтаксиса, запускать существующие тесты для проверки что ничего не сломалось, писать новые тесты для проверки нового функционала, проверять консоль браузера/терминала на ошибки и предупреждения, тестировать функционал вручную в разных сценариях. 3) После применения - проводить код-ревью сгенерированного кода как обычного кода от разработчика, проверять соответствие code style и проектным стандартам, рефакторить код если ИИ предложил неоптимальное решение, добавлять комментарии и документацию если ИИ их не добавил, обновлять связанную документацию и changelog, коммитить изменения с понятным commit message описывающим что было сделано. 4) Чек-лист проверки ответа ИИ - [ ] ИИ правильно понял задачу, [ ] Все упомянутые API/библиотеки существуют, [ ] Решение соответствует архитектуре проекта, [ ] Код компилируется без ошибок, [ ] Существующие тесты проходят, [ ] Новый функционал покрыт тестами, [ ] Нет проблем с безопасностью, [ ] Нет очевидных проблем с производительностью, [ ] Код соответствует проектным стандартам, [ ] Документация обновлена, [ ] Изменения задокументированы в changelog. 5) Работа с некорректными ответами - если ИИ дал неправильный ответ - не применять его, переформулировать запрос с дополнительным контекстом и уточнениями, разбить сложную задачу на более мелкие подзадачи для ИИ, предоставить ИИ примеры желаемого результата, использовать технику few-shot prompting с примерами, если ИИ продолжает ошибаться - решить задачу вручную и использовать как пример для будущих запросов, документировать проблемные области где ИИ часто ошибается"
      }
    },
    "quality": {
      "subcategories": [
        "Best Practices & Code Review"
      ],
      "descriptions": {
        "Best Practices & Code Review": "Стандарты качества при проверке кода от ИИ: 1) Код-ревью сгенерированного кода - применять те же стандарты код-ревью что и для кода от разработчиков, проверять читаемость и понятность кода (не использовать код который непонятен), валидировать что код следует принципам SOLID, DRY, KISS, проверять что функции и классы имеют единственную ответственность (SRP), валидировать правильность именования переменных, функций, классов, проверять что код имеет адекватную обработку ошибок, валидировать что нет дублирования кода, проверять что код оптимален и не содержит избыточной сложности. 2) Проверка соответствия стандартам - запуск ESLint/Prettier для проверки code style, валидация наличия JSDoc комментариев для публичных функций и классов, проверка что тесты следуют AAA-паттерну (Arrange-Act-Assert), валидация что код использует правильные паттерны из проектной документации, проверка что импорты организованы согласно проектным правилам, валидация что используются правильные типы (TypeScript) или JSDoc типы, проверка что код проходит все настроенные линтеры и статические анализаторы. 3) Метрики качества кода от ИИ - test coverage сгенерированного кода должен быть >80%, cyclomatic complexity функций должна быть <10, количество параметров функции должно быть <5, длина функции должна быть <50 строк, глубина вложенности должна быть <4 уровней, количество зависимостей модуля должно быть минимальным, code duplication должен быть <3%, maintainability index должен быть >65. 4) Автоматизация проверки - настройка pre-commit hooks для автоматической проверки кода от ИИ, интеграция с CI/CD для запуска всех проверок при push, использование GitHub Actions/GitLab CI для автоматического код-ревью, настройка SonarQube для комплексного анализа качества, использование Dependabot для проверки безопасности зависимостей, автоматическое создание отчетов о качестве кода в PR. 5) Документирование стандартов - создание руководства по проверке кода от ИИ для команды, документирование типичных проблем и способов их обнаружения, создание чек-листов для разных типов задач (новая фича, рефакторинг, исправление бага), примеры хороших и плохих ответов ИИ с объяснениями, best practices работы с ИИ-ассистентом в контексте проекта"
      }
    }
  }
}
