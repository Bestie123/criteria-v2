{
  "id": "023",
  "text": "Шаблон добавления новой фичи: структурированный процесс добавления нового функционала с ИИ-ассистентом, включающий анализ требований (описание фичи, бизнес-цели, пользовательские сценарии, acceptance criteria), архитектурное проектирование (выбор подхода с обоснованием, определение затрагиваемых модулей и компонентов, анализ влияния на существующий код, проектирование API и интерфейсов), планирование реализации (декомпозиция на подзадачи, определение зависимостей и порядка выполнения, оценка рисков и сложности), разработку с ИИ (точные файлы для создания/изменения с путями и MODULE_ID/FUNC_ID, инкрементальная реализация с проверками, написание тестов параллельно с кодом), интеграцию (обновление документации и changelog, проверка обратной совместимости, код-ревью и валидация), тестирование (unit тесты, интеграционные тесты, проверка edge cases, тестирование производительности)",
  "categories": [
    "ai-criteria",
    "processes",
    "prompts",
    "quality"
  ],
  "tags": [
    "feature",
    "новая фича",
    "разработка",
    "шаблон"
  ],
  "categories_info": [
    {
      "key": "ai-criteria",
      "title": "Критерии для нейросети",
      "description": "Требования к интеграции ИИ-помощника"
    },
    {
      "key": "processes",
      "title": "Процессы разработки",
      "description": "Методологии и практики работы команды"
    },
    {
      "key": "prompts",
      "title": "Промпты",
      "description": "Стандартизированные шаблоны запросов для ИИ"
    },
    {
      "key": "quality",
      "title": "Требования к качеству",
      "description": "Нефункциональные требования и стандарты"
    }
  ],
  "contexts": {
    "ai-criteria": {
      "subcategories": [],
      "descriptions": {
        "null": "ИИ-ассистент должен помогать в добавлении новой фичи: анализировать требования и задавать уточняющие вопросы для полного понимания (что именно нужно реализовать, для кого, зачем, какие ограничения), предлагать множественные архитектурные подходы с обоснованием плюсов и минусов каждого (новый модуль vs расширение существующего, различные паттерны проектирования, trade-offs между простотой и гибкостью), анализировать влияние на существующий код (какие модули затронуты, потенциальные breaking changes, необходимость рефакторинга), помогать в декомпозиции фичи на атомарные подзадачи с определением зависимостей и порядка выполнения, генерировать чеклисты обязательных действий для каждого этапа (код, тесты, документация, ревью), проверять соответствие архитектурным принципам проекта (SOLID, DRY, модульность, ограничение размера файлов), предлагать точки расширения для будущего развития фичи"
      }
    },
    "processes": {
      "subcategories": [
        "Работа с задачами"
      ],
      "descriptions": {
        "Работа с задачами": "Процесс добавления новой фичи состоит из 6 этапов: 1) Анализ требований - сбор и уточнение требований (что, зачем, для кого), определение acceptance criteria (критерии успешной реализации), анализ пользовательских сценариев (user stories, use cases), выявление ограничений и зависимостей (технические, бизнес, дизайн). 2) Архитектурное проектирование - выбор архитектурного подхода с обоснованием (новый модуль, расширение существующего, рефакторинг), определение затрагиваемых компонентов и модулей с MODULE_ID, проектирование API и интерфейсов (публичные методы, параметры, возвращаемые значения), анализ влияния на существующий код (breaking changes, миграция, обратная совместимость), создание диаграмм архитектуры и потоков данных. 3) Планирование реализации - декомпозиция фичи на подзадачи (атомарные, независимые, тестируемые), определение порядка выполнения и зависимостей между задачами, оценка сложности и рисков каждой подзадачи, создание чеклистов обязательных действий. 4) Разработка - инкрементальная реализация с проверкой работоспособности после каждого шага, написание unit тестов параллельно с кодом (TDD подход), добавление JSDoc комментариев и inline документации, соблюдение стандартов проекта (ESLint, Prettier, архитектурные принципы). 5) Интеграция - обновление документации (README, API docs, примеры использования), добавление записи в changelog с описанием фичи, проверка обратной совместимости и миграционных путей, код-ревью с фокусом на архитектуру и качество, обновление зависимых модулей и компонентов. 6) Тестирование и валидация - написание интеграционных тестов для проверки взаимодействия компонентов, тестирование edge cases и граничных условий, проверка производительности и утечек памяти, валидация соответствия acceptance criteria, сбор обратной связи от пользователей или команды"
      }
    },
    "prompts": {
      "subcategories": [
        "Шаблоны запросов"
      ],
      "descriptions": {
        "Шаблоны запросов": "Структура промпта для добавления новой фичи: 1) Описание фичи - что нужно реализовать (детальное описание функционала), зачем нужна фича (бизнес-цели, проблема которую решает), для кого предназначена (целевая аудитория, пользовательские сценарии), acceptance criteria (критерии успешной реализации, как проверить что фича работает), ограничения и требования (технические, производительность, совместимость, дизайн). 2) Контекст проекта - текущая архитектура (основные модули, паттерны, принципы), существующий функционал связанный с фичей (что уже есть, что можно переиспользовать), стандарты и соглашения проекта (code style, naming conventions, структура файлов), точки расширения и hooks если есть. 3) Запрос к ИИ - предложить несколько архитектурных подходов с обоснованием плюсов и минусов, определить затрагиваемые модули и компоненты (с MODULE_ID, FUNC_ID), спроектировать API и интерфейсы (публичные методы, параметры, типы), декомпозировать фичу на подзадачи с зависимостями, предложить порядок реализации (что делать первым, что потом), указать точные файлы для создания/изменения с абсолютными путями. 4) Ожидаемый ответ от ИИ - анализ требований с уточняющими вопросами, несколько вариантов архитектурных решений с trade-offs (простота vs гибкость, производительность vs читаемость), пошаговый план реализации с приоритизацией, список файлов и модулей для создания/изменения (с путями и идентификаторами), проектирование API с примерами использования, список зависимостей и компонентов требующих обновления, потенциальные риски и способы их минимизации, чеклист обязательных действий (код, тесты, документация, ревью, валидация). 5) Итерация - обсуждение предложенных вариантов и выбор оптимального подхода, уточнение деталей реализации, инкрементальная разработка с проверками после каждого шага, запрос ревью изменений у ИИ перед коммитом"
      }
    },
    "quality": {
      "subcategories": [
        "Best Practices & Code Review"
      ],
      "descriptions": {
        "Best Practices & Code Review": "Требования к качеству при добавлении новой фичи: соблюдение архитектурных принципов проекта (SOLID, DRY, модульность, слабая связанность), ограничение размера файлов (не более 500 строк кода), разделение ответственности (один файл - одна ответственность), написание тестов с покрытием >80% (unit тесты для каждой функции, интеграционные тесты для взаимодействия компонентов), добавление JSDoc комментариев для всех публичных API (описание, параметры, возвращаемые значения, примеры), обновление документации (README, API docs, changelog, примеры использования), проверка обратной совместимости (не ломать существующий функционал, миграционные пути для breaking changes), код-ревью с фокусом на архитектуру и качество (соответствие стандартам, читаемость, производительность, безопасность), проверка производительности и утечек памяти (профилирование, мониторинг), валидация соответствия acceptance criteria (все требования реализованы и работают корректно)"
      }
    }
  }
}