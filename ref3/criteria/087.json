{
  "id": "087",
  "text": "Принцип DRY (Don't Repeat Yourself): избегать дублирования кода через переиспользование модулей, функций и компонентов, извлечение общей логики в utility functions, shared modules, composition patterns, HOC, mixins, создание библиотек переиспользуемых компонентов, применение паттернов проектирования для устранения повторений, рефакторинг дублирующегося кода в централизованные решения",
  "categories": [
    "architecture",
    "editor",
    "ai-criteria",
    "prompts",
    "quality"
  ],
  "tags": [
    "DRY",
    "переиспользование",
    "utility functions",
    "shared modules",
    "composition",
    "HOC",
    "mixins",
    "рефакторинг",
    "дублирование"
  ],
  "categories_info": [
    {
      "key": "ai-criteria",
      "title": "Критерии для нейросети",
      "description": "Требования к интеграции ИИ-помощника"
    },
    {
      "key": "architecture",
      "title": "Общие архитектурные принципы для движка",
      "description": "Фундаментальные правила построения всей системы"
    },
    {
      "key": "editor",
      "title": "Движок редактора",
      "description": "Требования к ядру редактора"
    },
    {
      "key": "prompts",
      "title": "Промпты",
      "description": "Стандартизированные шаблоны запросов для ИИ"
    },
    {
      "key": "quality",
      "title": "Требования к качеству",
      "description": "Нефункциональные требования и стандарты"
    }
  ],
  "contexts": {
    "architecture": {
      "subcategories": [],
      "descriptions": {
        "null": "Следовать принципу DRY (Don't Repeat Yourself) - избегать дублирования кода через переиспользование модулей и компонентов. Техники: извлечение общей логики в utility functions (formatDate, validateEmail, debounce), создание shared modules для переиспользуемой бизнес-логики, применение composition over inheritance для гибкого переиспользования, использование dependency injection для инверсии зависимостей, создание abstract base classes и interfaces для общего поведения, применение паттернов Strategy, Template Method, Decorator для устранения дублирования, централизация конфигурации и констант в config modules"
      }
    },
    "editor": {
      "subcategories": [],
      "descriptions": {
        "null": "Переиспользование блоков и компонентов редактора вместо дублирования функциональности. Техники: создание библиотеки переиспользуемых UI компонентов (кнопки, формы, модальные окна, таблицы), композиция блоков из более мелких переиспользуемых частей, использование slots/templates для кастомизации переиспользуемых компонентов, создание Higher-Order Components (HOC) для добавления общего поведения, применение render props и compound components паттернов, централизация стилей через CSS modules или styled-components, переиспользование логики через custom hooks (React) или composables (Vue), создание plugin системы для расширения функциональности без дублирования"
      }
    },
    "ai-criteria": {
      "subcategories": [],
      "descriptions": {
        "null": "При генерации кода ИИ должен выявлять и устранять дублирование, предлагая переиспользуемые решения. Техники: автоматическое обнаружение повторяющихся паттернов кода и предложение извлечения в функции, генерация utility functions для часто используемых операций, предложение использования существующих модулей вместо создания новых, рефакторинг похожих функций в параметризованные версии, создание generic/template функций для типовых операций, предложение паттернов проектирования для устранения дублирования, генерация документации с примерами переиспользования, проверка кодовой базы на существующие решения перед генерацией нового кода"
      }
    },
    "prompts": {
      "subcategories": [
        "Конструктивная критика (шаблоны)"
      ],
      "descriptions": {
        "Конструктивная критика (шаблоны)": "Выявлять дублирование кода и предлагать рефакторинг с извлечением общей логики. Шаблон анализа: 1) Идентификация дублирующихся блоков кода (copy-paste код, похожие функции с минимальными отличиями, повторяющиеся паттерны), 2) Оценка степени дублирования (количество повторений, размер дублирующегося кода, сложность логики), 3) Предложение техники рефакторинга (Extract Method для повторяющейся логики, Extract Class для группы связанных методов, Parameterize Method для похожих функций с разными параметрами, Replace Conditional with Polymorphism для повторяющихся switch/if-else, Introduce Parameter Object для группы параметров), 4) Демонстрация до/после с измеримыми улучшениями (уменьшение строк кода, улучшение читаемости, упрощение тестирования)"
      }
    },
    "quality": {
      "subcategories": [
        "Best Practices & Code Review",
        "Рефакторинг"
      ],
      "descriptions": {
        "Best Practices & Code Review": "При code review проверять соблюдение принципа DRY и отсутствие дублирования логики. Чек-лист проверки: 1) Поиск copy-paste кода (идентичные или почти идентичные блоки кода в разных местах), 2) Проверка на magic numbers и magic strings (должны быть вынесены в константы), 3) Выявление повторяющихся паттернов (похожие функции, классы, компоненты), 4) Проверка на дублирование бизнес-логики (одна и та же логика в разных слоях приложения), 5) Анализ конфигурации (дублирующиеся настройки должны быть централизованы), 6) Проверка тестов на дублирование (повторяющийся setup код должен быть в beforeEach/fixtures), 7) Оценка возможности переиспользования (можно ли извлечь общую логику в utility/helper), 8) Проверка документации (описание переиспользуемых компонентов и их API)",
        "Рефакторинг": "Устранение дублирования кода как приоритетная цель рефакторинга. Стратегия рефакторинга: 1) Идентификация дублирования (использование инструментов: jscpd, PMD Copy/Paste Detector, SonarQube для автоматического обнаружения), 2) Приоритизация (начинать с наиболее часто дублируемого кода, критических модулей, кода с высокой сложностью), 3) Техники устранения (Extract Method - извлечение повторяющейся логики в отдельную функцию, Extract Class - группировка связанных методов в класс, Pull Up Method - перенос общих методов в базовый класс, Form Template Method - создание шаблонного метода для общего алгоритма, Replace Magic Number with Symbolic Constant - замена магических чисел на константы, Consolidate Duplicate Conditional Fragments - объединение дублирующихся условий), 4) Тестирование (запуск всех тестов после каждого шага рефакторинга, добавление тестов для новых переиспользуемых компонентов), 5) Документирование (описание переиспользуемых компонентов, примеры использования, API документация), 6) Метрики (измерение уменьшения дублирования через code coverage и duplication metrics)"
      }
    }
  }
}
