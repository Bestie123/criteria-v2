{
  "id": "004",
  "text": "Взаимодействие в реальном времени: живое обновление всех связанных элементов при изменении источника без перезагрузки страницы, block references и embeds с автоматическим обновлением контента при изменении оригинального блока, синхронизация связанных данных между таблицами, диаграммами, формулами и текстом в реальном времени, использование WebSocket или Server-Sent Events (SSE) для двусторонней связи клиент-сервер, optimistic updates с мгновенным отображением изменений и последующей синхронизацией с сервером, conflict resolution при одновременном редактировании одного элемента несколькими пользователями, автоматический rollback при ошибках синхронизации, визуальная индикация статуса синхронизации (синхронизировано, синхронизация, ошибка), offline-first подход с локальным кэшированием и синхронизацией при восстановлении соединения, event-driven архитектура для реактивного обновления UI, debouncing и throttling для оптимизации частоты обновлений",
  "categories": [
    "architecture",
    "editor",
    "quality",
    "tools"
  ],
  "tags": [
    "реальное время",
    "live updates",
    "WebSocket",
    "синхронизация",
    "block references",
    "reactive",
    "offline-first"
  ],
  "categories_info": [
    {
      "key": "architecture",
      "title": "Общие архитектурные принципы для движка",
      "description": "Фундаментальные правила построения всей системы"
    },
    {
      "key": "editor",
      "title": "Движок редактора",
      "description": "Требования к ядру редактора"
    },
    {
      "key": "quality",
      "title": "Требования к качеству",
      "description": "Нефункциональные требования и стандарты"
    },
    {
      "key": "tools",
      "title": "Инструменты",
      "description": "Практические инструменты для упрощения парной разработки с ИИ-ассистентом"
    }
  ],
  "contexts": {
    "architecture": {
      "subcategories": [],
      "descriptions": {
        "null": "Архитектурные принципы реального времени: 1) Event-driven архитектура - использование паттерна Observer/PubSub для реактивного обновления UI, события изменения данных (onBlockUpdate, onBlockDelete, onBlockMove), подписка компонентов на изменения связанных данных, автоматическое распространение изменений по всему графу зависимостей, каскадное обновление зависимых элементов. 2) Реактивная система данных - реактивные переменные и computed values (как в Vue/Svelte), автоматическое отслеживание зависимостей между данными, граф зависимостей для определения что нужно обновить, минимизация ре-рендеринга через точечные обновления, immutable data structures для предсказуемости изменений. 3) Offline-first подход - локальное хранилище как источник истины (IndexedDB, LocalStorage), синхронизация с сервером в фоновом режиме, очередь изменений для отправки при восстановлении соединения, conflict-free replicated data types (CRDT) для бесконфликтного слияния, автоматическое разрешение конфликтов где возможно. 4) Масштабируемость - горизонтальное масштабирование WebSocket серверов, использование Redis Pub/Sub для синхронизации между серверами, sharding пользователей по WebSocket серверам, балансировка нагрузки с sticky sessions, оптимизация размера сообщений через binary protocols (MessagePack, Protocol Buffers)"
      }
    },
    "editor": {
      "subcategories": [
        "Блоки контента",
        "Навигация и связи"
      ],
      "descriptions": {
        "Блоки контента": "Живое обновление блоков и связей: 1) Block references и embeds - вставка ссылки на блок с автоматическим отображением его содержимого, live preview встроенного блока с обновлением при изменении оригинала, визуальная индикация что блок является ссылкой (иконка, рамка), клик по reference для перехода к оригинальному блоку, поддержка вложенных references (блок A ссылается на блок B который ссылается на блок C), предотвращение циклических ссылок, кэширование содержимого references для производительности. 2) Синхронизация связанных данных - изменение в таблице автоматически обновляет связанную диаграмму, обновление формулы пересчитывает все зависимые ячейки, изменение переменной обновляет все места использования, rollup и aggregation с автоматическим пересчетом, двусторонняя синхронизация (изменение в диаграмме обновляет таблицу). 3) Optimistic updates - мгновенное отображение изменений в UI до подтверждения сервера, визуальная индикация неподтвержденных изменений (opacity, иконка часов), автоматический rollback при ошибке синхронизации с сервера, retry механизм для неудачных обновлений, очередь pending изменений с приоритетами. 4) Визуальная обратная связь - индикатор статуса синхронизации (зеленая галочка, спиннер, красный крестик), timestamp последней синхронизации, уведомления об ошибках синхронизации, progress bar для больших операций, toast notifications для важных событий",
        "Навигация и связи": "Управление связями в реальном времени: автоматическое обновление backlinks при изменении ссылок, live update графа зависимостей при добавлении/удалении связей, уведомления о изменениях в связанных блоках, подписка на изменения конкретных блоков, фильтрация уведомлений по важности, batch updates для множественных изменений, debouncing обновлений для снижения нагрузки"
      }
    },
    "quality": {
      "subcategories": [
        "Производительность"
      ],
      "descriptions": {
        "Производительность": "Оптимизация обновлений в реальном времени: 1) Debouncing и throttling - ограничение частоты отправки изменений на сервер (например максимум 1 раз в 500ms), группировка множественных изменений в один batch, приоритизация критичных обновлений, отложенная синхронизация некритичных изменений. 2) Минимизация трафика - отправка только измененных полей (delta updates), сжатие данных (gzip, brotli), binary protocols вместо JSON где возможно, incremental sync вместо полной перезагрузки, pagination для больших списков изменений. 3) Кэширование - локальное кэширование часто используемых данных, cache invalidation при изменениях, stale-while-revalidate стратегия, предзагрузка вероятных следующих данных, service worker для offline кэширования. 4) Виртуализация - рендеринг только видимых элементов при большом количестве обновлений, lazy loading для offscreen контента, windowing для длинных списков, progressive rendering для сложных блоков"
      }
    },
    "tools": {
      "subcategories": [],
      "descriptions": {
        "null": "Технологии и инструменты реального времени: 1) WebSocket - двусторонняя связь клиент-сервер для мгновенных обновлений, автоматическое переподключение при разрыве соединения, heartbeat/ping-pong для проверки соединения, graceful degradation к long polling при недоступности WebSocket, библиотеки Socket.io или native WebSocket API. 2) Server-Sent Events (SSE) - односторонняя связь сервер→клиент для push уведомлений, автоматическое переподключение встроено в браузер, проще чем WebSocket для read-only обновлений, EventSource API в браузере. 3) Библиотеки синхронизации - Yjs для CRDT и collaborative editing, Automerge для conflict-free data sync, ShareDB для real-time database, Firebase Realtime Database или Firestore, Supabase Realtime для PostgreSQL. 4) State management - Redux/Zustand с middleware для синхронизации, MobX для реактивности, Recoil для React, Pinia для Vue, RxJS для reactive streams. 5) Мониторинг - отслеживание latency обновлений, метрики успешности синхронизации, алерты при проблемах с WebSocket, dashboard с real-time статистикой, логирование конфликтов и их разрешения"
      }
    }
  }
}
