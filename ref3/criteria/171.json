{
  "id": "171",
  "text": "Построение диаграмм, стеков и порядков вызова функций через множественные инструменты: IntelliSense для автодополнения и навигации по вызовам с type hints, JSDoc для документирования call chains и генерации sequence diagrams, Puppeteer + CDP для динамической трассировки реальных вызовов и построения call stacks, DevTools для анализа Performance call tree и Memory allocations, автоматическая генерация диаграмм вызовов (Mermaid, PlantUML, Graphviz) через AST анализ, визуализация порядка выполнения функций с временными метриками, выявление критических путей и bottlenecks",
  "categories": [
    "tools",
    "quality",
    "ai-criteria"
  ],
  "tags": [
    "AST",
    "CDP",
    "DevTools",
    "Graphviz",
    "IntelliSense",
    "JSDoc",
    "Mermaid",
    "PlantUML",
    "Puppeteer",
    "call graph",
    "call hierarchy",
    "call stack",
    "sequence diagram",
    "визуализация",
    "диаграммы",
    "критические пути",
    "навигация",
    "отладка",
    "порядок вызовов",
    "стек вызовов",
    "трассировка"
  ],
  "categories_info": [
    {
      "key": "tools",
      "title": "Инструменты",
      "description": "Практические инструменты для упрощения парной разработки с ИИ-ассистентом"
    },
    {
      "key": "quality",
      "title": "Требования к качеству",
      "description": "Нефункциональные требования и стандарты"
    },
    {
      "key": "ai-criteria",
      "title": "Критерии для нейросети",
      "description": "Требования к интеграции ИИ-помощника"
    }
  ],
  "contexts": {
    "tools": {
      "subcategories": [],
      "descriptions": {
        "null": "Комплексное использование инструментов для построения диаграмм, стеков и порядков вызова функций. IntelliSense интеграция: автодополнение с отображением call signatures и type hints при вводе, навигация по вызовам через Ctrl+Click на имени функции, peek definition для быстрого просмотра реализации без перехода, parameter hints с документацией из JSDoc при вызове функции, автоматические импорты при использовании функций из других модулей, refactoring tools с автообновлением всех call sites. JSDoc для документирования вызовов: @see теги для ссылок на связанные функции в call chain, @example с типичными паттернами вызовов, @param и @returns для документирования сигнатур, @throws для документирования исключений в call path, автогенерация sequence diagrams из JSDoc комментариев через tools (jsdoc-to-markdown, documentation.js), создание call flow documentation с порядком вызовов. Puppeteer + CDP для динамической трассировки: запись реальных вызовов функций во время выполнения через Runtime.enable и Debugger.enable, перехват всех function calls через Debugger.scriptParsed и Debugger.paused, построение динамического call stack с временными метриками (время входа/выхода из функции), профилирование производительности критических путей через Profiler.start/stop, выявление неожиданных вызовов и бесконечных рекурсий, запись call traces в JSON для последующего анализа, визуализация порядка выполнения с flame graphs. DevTools интеграция: Performance panel для анализа call tree с временными метриками (self time, total time), Memory panel для отслеживания allocations по call stack и выявления утечек, Coverage panel для выявления неиспользуемого кода и dead call paths, Sources panel с breakpoints для пошаговой отладки вызовов и инспекции call stack, Console для логирования вызовов с console.trace() для stack traces, Network panel для анализа вызовов API и async operations. Автоматическая генерация диаграмм: использование AST парсеров (Babel, TypeScript Compiler API, Acorn, Esprima) для статического анализа кода, построение call graph в формате Mermaid (sequence diagram, flowchart), PlantUML для UML sequence diagrams, Graphviz DOT для directed graphs, D3.js для интерактивных визуализаций, автоматическое обновление диаграмм при изменении кода через file watchers, экспорт диаграмм в SVG/PNG/PDF для документации, интерактивные диаграммы с навигацией по клику на функцию. Инструменты статического анализа: madge для визуализации зависимостей модулей и circular dependencies, dependency-cruiser для проверки правил зависимостей и архитектурных ограничений, source-map-explorer для анализа размера бандлов по call paths, webpack-bundle-analyzer для оптимизации и tree shaking"
      }
    },
    "quality": {
      "subcategories": [
        "Архитектурная целостность",
        "Best Practices & Code Review"
      ],
      "descriptions": {
        "Архитектурная целостность": "Визуализация дерева вызовов для понимания архитектуры и выявления проблем. Анализ связанности: выявление сильно связанных компонентов (high coupling), обнаружение циклических зависимостей на уровне функций, поиск god functions с большим количеством вызовов, идентификация orphan functions без вызовов (кандидаты на удаление). Критические пути выполнения: построение графа критических путей от entry points до leaf functions, анализ глубины вызовов (call depth) для выявления сложных цепочек, выявление bottleneck функций с большим количеством callers, документирование критических путей для новых разработчиков. Метрики качества: цикломатическая сложность путей вызовов, fan-in (количество вызывающих) и fan-out (количество вызываемых) для каждой функции, coupling metrics между модулями через вызовы, cohesion metrics внутри модулей",
        "Best Practices & Code Review": "Использование анализа вызовов при code review. Проверки при ревью: все публичные функции имеют callers (не dead code), критические функции не вызываются из неожиданных мест, глубина вызовов не превышает разумных пределов (< 10 уровней), отсутствие циклических вызовов и бесконечных рекурсий. Рефакторинг на основе анализа: извлечение часто вызываемых блоков в отдельные функции, разбиение god functions с большим fan-out, устранение дублирования через анализ похожих call patterns, оптимизация критических путей с высокой частотой вызовов. Документирование связей: добавление JSDoc @see ссылок на связанные функции, документирование критических путей в README, создание sequence diagrams для сложных взаимодействий, поддержание актуальности диаграмм вызовов"
      }
    },
    "ai-criteria": {
      "subcategories": [],
      "descriptions": {
        "null": "ИИ-ассистент использует анализ дерева вызовов для улучшения генерации и рефакторинга кода. Контекст для генерации: ИИ анализирует существующие call patterns в проекте для генерации согласованного кода, понимает, как новая функция будет вызываться и кого будет вызывать, предлагает интеграцию новой функции в существующие call chains, проверяет, не создаст ли новый код циклические зависимости. Безопасный рефакторинг: ИИ видит все места вызова функции перед рефакторингом (callers), автоматически обновляет все call sites при изменении сигнатуры, предупреждает о breaking changes в публичных API, предлагает deprecation path для функций с большим количеством callers. Умные предложения на основе call graph: выявление дублирующихся call patterns для извлечения в utility functions, предложение мемоизации для часто вызываемых pure functions, оптимизация порядка вызовов для улучшения производительности, рефакторинг глубоких call chains в более плоские структуры. Анализ влияния изменений: ИИ строит граф зависимостей от изменяемой функции, оценивает количество затронутых модулей и функций, предлагает тесты для всех affected call paths, генерирует migration guide для breaking changes. Интеграция с JSDoc: автоматическое добавление @see ссылок на связанные функции, генерация @example с типичными call patterns, документирование call chains в комментариях, создание sequence diagrams из call graph"
      }
    }
  }
}
