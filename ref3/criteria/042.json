{
  "id": "042",
  "text": "Проверки на утечки памяти и профилирование: регулярное профилирование использования памяти приложением, обнаружение утечек памяти через инструменты (Chrome DevTools Memory Profiler, heap snapshots, allocation timeline), анализ типичных причин утечек (незачищенные event listeners, замыкания, глобальные переменные, detached DOM nodes, кэши без ограничений), автоматизация проверок через тесты и CI/CD, мониторинг потребления памяти в production, best practices предотвращения утечек (правильная очистка ресурсов, WeakMap/WeakSet, dispose паттерн), использование memory leak detection библиотек, документирование найденных и исправленных утечек",
  "categories": [
    "processes",
    "quality",
    "tools"
  ],
  "tags": [
    "DevTools",
    "heap snapshots",
    "memory leaks",
    "performance",
    "производительность",
    "профилирование",
    "мониторинг"
  ],
  "categories_info": [
    {
      "key": "processes",
      "title": "Процессы разработки",
      "description": "Методологии и практики работы команды"
    },
    {
      "key": "quality",
      "title": "Требования к качеству",
      "description": "Нефункциональные требования и стандарты"
    },
    {
      "key": "tools",
      "title": "Инструменты",
      "description": "Практические инструменты для упрощения парной разработки с ИИ-ассистентом"
    }
  ],
  "contexts": {
    "quality": {
      "subcategories": [
        "Производительность"
      ],
      "descriptions": {
        "Производительность": "Требования к проверкам памяти и предотвращению утечек: 1) Метрики и пороги - установка максимальных порогов потребления памяти для приложения (например heap size не должен превышать 500MB для SPA), мониторинг роста памяти во времени (memory growth rate должен быть близок к нулю при стабильной работе), отслеживание количества DOM nodes (не более 1500 для оптимальной производительности), контроль количества event listeners (регулярная очистка неиспользуемых), измерение времени garbage collection и его влияния на производительность. 2) Типичные причины утечек - незачищенные event listeners (addEventListener без removeEventListener при удалении элементов), замыкания удерживающие большие объекты в памяти (closure memory leaks), глобальные переменные и случайное создание глобальных переменных (забытый var/let в strict mode), detached DOM nodes (элементы удаленные из DOM но сохраненные в переменных), кэши без ограничений размера и времени жизни (unbounded caches), таймеры и интервалы не очищенные при unmount (setInterval, setTimeout), circular references в старых браузерах, большие данные в closure не освобождаемые после использования. 3) Best practices предотвращения - правильная очистка ресурсов при unmount/destroy компонентов (cleanup в useEffect, componentWillUnmount, dispose методы), использование WeakMap и WeakSet для хранения ссылок на объекты без предотвращения их сборки мусора, реализация dispose/cleanup паттерна для объектов с ресурсами, ограничение размера кэшей (LRU cache с максимальным размером), использование object pooling для часто создаваемых объектов, избегание создания функций в render/update циклах, правильное управление подписками (subscriptions) и их отмена, использование AbortController для отмены fetch запросов. 4) Регулярные проверки - профилирование памяти при каждом крупном изменении функционала, heap snapshots до и после выполнения операций для сравнения, проверка на утечки при длительной работе приложения (stress testing), автоматические тесты на утечки памяти в CI/CD, code review с фокусом на потенциальные утечки (event listeners, subscriptions, timers), документирование паттернов работы с памятью в проекте"
      }
    },
    "processes": {
      "subcategories": [
        "Troubleshooting и отладка"
      ],
      "descriptions": {
        "Troubleshooting и отладка": "Процесс обнаружения и исправления утечек памяти: 1) Обнаружение утечек - мониторинг потребления памяти в production через метрики (Datadog, New Relic, CloudWatch), выявление аномального роста памяти через графики и алерты, воспроизведение проблемы в dev окружении для анализа, использование Chrome DevTools Memory Profiler для профилирования, создание heap snapshots в разные моменты времени для сравнения, анализ allocation timeline для определения где выделяется память. 2) Анализ heap snapshots - создание baseline snapshot перед выполнением операции, выполнение подозрительной операции многократно (например 10 раз), создание второго snapshot и сравнение с baseline, поиск объектов которые не были освобождены (retained objects), анализ retaining tree для понимания что удерживает объекты в памяти, фильтрация по типам объектов (Detached DOM nodes, Event listeners, Closures), идентификация источника утечки через stack traces создания объектов. 3) Использование DevTools - Memory panel для профилирования и heap snapshots, Performance panel для записи timeline с памятью, Allocation instrumentation on timeline для отслеживания выделений в реальном времени, Allocation sampling для легковесного профилирования, Console для ручного вызова gc() и проверки (с флагом --expose-gc), Coverage для определения неиспользуемого кода загружающего память. 4) Исправление утечек - добавление cleanup логики в соответствующие lifecycle методы (componentWillUnmount, useEffect cleanup, dispose), замена сильных ссылок на WeakMap/WeakSet где возможно, добавление removeEventListener для всех addEventListener, очистка таймеров через clearInterval/clearTimeout, отмена подписок и запросов при unmount, ограничение размера кэшей и добавление eviction политик, рефакторинг замыканий для освобождения больших объектов, добавление тестов проверяющих отсутствие утечек после исправления. 5) Валидация исправления - повторное профилирование после исправления, сравнение heap snapshots до и после фикса, проверка что память освобождается после выполнения операций, длительное тестирование (несколько часов работы) для подтверждения, мониторинг в production после деплоя исправления, документирование найденной утечки и способа исправления для будущих reference. 6) Документирование - создание базы знаний с типичными утечками в проекте, документирование паттернов которые приводят к утечкам, создание чеклиста для code review (проверка cleanup, event listeners, subscriptions), обучение команды на примерах найденных утечек, добавление линтер правил для автоматического обнаружения потенциальных утечек"
      }
    },
    "tools": {
      "subcategories": [],
      "descriptions": {
        "null": "Инструменты для обнаружения и анализа утечек памяти: 1) Chrome DevTools Memory Profiler - встроенный инструмент для профилирования памяти в Chrome/Edge, heap snapshots для снимков состояния памяти в конкретный момент времени с детальной информацией о всех объектах, allocation timeline для отслеживания выделений памяти во времени, allocation sampling для легковесного профилирования с меньшим overhead, comparison view для сравнения двух snapshots и выявления утечек, retaining tree для понимания цепочки ссылок удерживающих объекты, фильтры по типам объектов (Detached DOM, Event listeners, Arrays, Strings), поиск по constructor name для нахождения конкретных объектов. 2) Performance Monitor - реалтайм мониторинг метрик памяти (JS heap size, DOM nodes, event listeners, documents), визуализация изменений во времени через графики, быстрое обнаружение аномального роста памяти, легковесный мониторинг без необходимости создания snapshots, интеграция с Performance panel для комплексного анализа. 3) Memory leak detection библиотеки - memlab от Meta для автоматического обнаружения утечек через сценарии, leak-detect для unit тестов проверяющих утечки, fuite для E2E тестов на утечки памяти, heapdump для создания heap dumps в Node.js, node-memwatch для мониторинга памяти в Node.js приложениях, clinic.js для диагностики производительности Node.js. 4) Автоматизация проверок - интеграция memory leak тестов в CI/CD пайплайн, автоматическое создание heap snapshots при деплое в staging, скрипты для сравнения snapshots и выявления регрессий, алерты при превышении порогов потребления памяти, регулярные scheduled проверки на утечки в production. 5) Production мониторинг - интеграция с APM системами (Datadog, New Relic, AppDynamics) для мониторинга памяти, настройка алертов на аномальный рост heap size, сбор метрик garbage collection (frequency, duration, pause time), мониторинг memory pressure и OOM (Out of Memory) событий, корреляция проблем с памятью с конкретными features или user actions, автоматическое создание heap dumps при приближении к OOM для post-mortem анализа. 6) Puppeteer + CDP для автоматизации - программное создание heap snapshots через Chrome DevTools Protocol, автоматизация сценариев воспроизведения утечек, сравнение snapshots программно для CI/CD, мониторинг метрик памяти во время E2E тестов, создание отчетов о потреблении памяти, интеграция с системами непрерывного мониторинга качества"
      }
    }
  }
}