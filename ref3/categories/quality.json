{
  "version": "3.0",
  "generated": true,
  "category": "quality",
  "name": "Требования к качеству",
  "description": "Нефункциональные требования и стандарты",
  "criteria": [
    {
      "id": "003",
      "text": "Блочная архитектура редактора: каждый элемент контента (абзац, заголовок, таблица, изображение, формула, диаграмма, код) является независимым блоком с уникальным ID, типом, содержимым, метаданными, поддержкой вложенности и CRUD операций через API",
      "tags": [
        "API",
        "CRUD",
        "UUID",
        "блоки",
        "вложенность",
        "независимость",
        "типы блоков"
      ]
    },
    {
      "id": "004",
      "text": "Взаимодействие в реальном времени: живое обновление всех связанных элементов при изменении источника без перезагрузки страницы, block references и embeds с автоматическим обновлением контента при изменении оригинального блока, синхронизация связанных данных между таблицами, диаграммами, формулами и текстом в реальном времени, использование WebSocket или Server-Sent Events (SSE) для двусторонней связи клиент-сервер, optimistic updates с мгновенным отображением изменений и последующей синхронизацией с сервером, conflict resolution при одновременном редактировании одного элемента несколькими пользователями, автоматический rollback при ошибках синхронизации, визуальная индикация статуса синхронизации (синхронизировано, синхронизация, ошибка), offline-first подход с локальным кэшированием и синхронизацией при восстановлении соединения, event-driven архитектура для реактивного обновления UI, debouncing и throttling для оптимизации частоты обновлений",
      "tags": [
        "реальное время",
        "live updates",
        "WebSocket",
        "синхронизация",
        "block references",
        "reactive",
        "offline-first"
      ]
    },
    {
      "id": "005",
      "text": "Система плагинов и расширяемости: архитектура плагинов с изолированными папками и манифестами (plugin.json), официальный магазин плагинов с рейтингами, API для создания плагинов (JavaScript, TypeScript, Rust, WASM), поддержка популярных типов (диаграммы Mermaid/Excalidraw/tldraw, математика KaTeX, таблицы Advanced Tables, канбан, календари, PDF-аннотации, AI-плагины), веб-хуки для внешних интеграций, sandbox изоляция для безопасности, lifecycle управление (load, enable, disable, unload), версионирование и автоматическое обновление, точки расширения через hooks и events, dependency injection, валидация плагинов перед публикацией",
      "tags": [
        "API",
        "Advanced Tables",
        "Excalidraw",
        "JavaScript",
        "KaTeX",
        "Mermaid",
        "Rust",
        "WASM",
        "dependency injection",
        "hooks",
        "lifecycle",
        "sandbox",
        "tldraw",
        "версионирование",
        "веб-хуки",
        "магазин плагинов",
        "плагины",
        "расширяемость"
      ]
    },
    {
      "id": "009",
      "text": "Система уникальных идентификаторов блоков: генерация UUID v4 или custom BLOCK_ID при создании, гарантия глобальной уникальности, неизменность ID на протяжении жизненного цикла, использование в ссылках и упоминаниях, хранение в data-атрибутах DOM, индексация для быстрого поиска O(1), валидация при загрузке, интеграция с версионированием и историей изменений",
      "tags": [
        "BLOCK_ID",
        "ID",
        "UUID",
        "блоки",
        "валидация",
        "индексация",
        "уникальность"
      ]
    },
    {
      "id": "010",
      "text": "Перемещение блоков: возможность перемещать блоки внутри документа и между документами с сохранением всех свойств и связей, drag-and-drop перемещение блоков мышью с визуальной индикацией места вставки, горячие клавиши для перемещения блоков вверх/вниз (Alt+Up/Down или Cmd+Shift+Up/Down), трансформация типа блока (преобразование текста в заголовок, список в чек-лист, параграфа в цитату и обратно) через меню или slash-команды, копирование и вставка блоков с сохранением форматирования, перемещение блоков между разными страницами/документами через drag-and-drop или cut/paste, множественное выделение и перемещение группы блоков одновременно, отмена/повтор операций перемещения (undo/redo), сохранение истории перемещений для аудита, автоматическое обновление ссылок и связей при перемещении блоков, предпросмотр результата перемещения перед применением",
      "tags": [
        "блоки",
        "UX",
        "drag-and-drop",
        "трансформация",
        "горячие клавиши",
        "копирование",
        "перемещение"
      ]
    },
    {
      "id": "013",
      "text": "Генерация документации для файлов, модулей, функций и API",
      "tags": [
        "документация"
      ]
    },
    {
      "id": "014",
      "text": "Множественные варианты решений",
      "tags": [
        "варианты"
      ]
    },
    {
      "id": "015",
      "text": "Альтернативные подходы к рефакторингу",
      "tags": [
        "рефакторинг"
      ]
    },
    {
      "id": "016",
      "text": "Пошаговое планирование рефакторинга",
      "tags": [
        "рефакторинг",
        "планирование"
      ]
    },
    {
      "id": "019",
      "text": "Фокус на одной задаче",
      "tags": [
        "фокус"
      ]
    },
    {
      "id": "023",
      "text": "Шаблон добавления новой фичи: структурированный процесс добавления нового функционала с ИИ-ассистентом, включающий анализ требований (описание фичи, бизнес-цели, пользовательские сценарии, acceptance criteria), архитектурное проектирование (выбор подхода с обоснованием, определение затрагиваемых модулей и компонентов, анализ влияния на существующий код, проектирование API и интерфейсов), планирование реализации (декомпозиция на подзадачи, определение зависимостей и порядка выполнения, оценка рисков и сложности), разработку с ИИ (точные файлы для создания/изменения с путями и MODULE_ID/FUNC_ID, инкрементальная реализация с проверками, написание тестов параллельно с кодом), интеграцию (обновление документации и changelog, проверка обратной совместимости, код-ревью и валидация), тестирование (unit тесты, интеграционные тесты, проверка edge cases, тестирование производительности)",
      "tags": [
        "feature",
        "новая фича",
        "разработка",
        "шаблон"
      ]
    },
    {
      "id": "025",
      "text": "Архитектурное соответствие",
      "tags": [
        "архитектура"
      ]
    },
    {
      "id": "027",
      "text": "Оценка архитектурных компромиссов",
      "tags": [
        "trade-offs"
      ]
    },
    {
      "id": "029",
      "text": "Улучшения функционала/архитектуры",
      "tags": [
        "улучшения"
      ]
    },
    {
      "id": "031",
      "text": "Языковые/фреймворковые best practices",
      "tags": [
        "best practices"
      ]
    },
    {
      "id": "032",
      "text": "Инкрементальные безопасные изменения",
      "tags": [
        "безопасность",
        "инкрементальность"
      ]
    },
    {
      "id": "033",
      "text": "Стабильность API критических компонентов",
      "tags": [
        "API",
        "стабильность"
      ]
    },
    {
      "id": "034",
      "text": "Полное тестовое покрытие",
      "tags": [
        "тесты"
      ]
    },
    {
      "id": "035",
      "text": "Архитектурная документация",
      "tags": [
        "документация"
      ]
    },
    {
      "id": "036",
      "text": "Изоляция от бизнес-логики",
      "tags": [
        "изоляция"
      ]
    },
    {
      "id": "037",
      "text": "Управление зависимостями",
      "tags": [
        "зависимости"
      ]
    },
    {
      "id": "038",
      "text": "Архитектурное ревью",
      "tags": [
        "ревью"
      ]
    },
    {
      "id": "039",
      "text": "Покрытие тестами >80%",
      "tags": [
        "тесты"
      ]
    },
    {
      "id": "040",
      "text": "Интеграционные тесты",
      "tags": [
        "тесты"
      ]
    },
    {
      "id": "041",
      "text": "Unit тесты для изолированного тестирования компонентов: написание модульных тестов для каждой функции, класса и модуля, изоляция тестируемого кода от зависимостей через mocking и stubbing, использование AAA-паттерна (Arrange-Act-Assert) для структуры тестов, покрытие различных сценариев (happy path, edge cases, error cases), автоматический запуск тестов через test runner, интеграция с CI/CD для автоматического тестирования при коммитах, поддержание высокого test coverage (>80%), использование test frameworks (Jest, Mocha, Pytest, JUnit), параметризованные тесты для проверки множества входных данных, snapshot тесты для UI компонентов",
      "tags": [
        "AAA-паттерн",
        "TDD",
        "mocking",
        "test coverage",
        "unit testing",
        "тесты"
      ]
    },
    {
      "id": "042",
      "text": "Проверки на утечки памяти и профилирование: регулярное профилирование использования памяти приложением, обнаружение утечек памяти через инструменты (Chrome DevTools Memory Profiler, heap snapshots, allocation timeline), анализ типичных причин утечек (незачищенные event listeners, замыкания, глобальные переменные, detached DOM nodes, кэши без ограничений), автоматизация проверок через тесты и CI/CD, мониторинг потребления памяти в production, best practices предотвращения утечек (правильная очистка ресурсов, WeakMap/WeakSet, dispose паттерн), использование memory leak detection библиотек, документирование найденных и исправленных утечек",
      "tags": [
        "DevTools",
        "heap snapshots",
        "memory leaks",
        "performance",
        "производительность",
        "профилирование",
        "мониторинг"
      ]
    },
    {
      "id": "043",
      "text": "Бенчмарки производительности: систематическое тестирование производительности критических операций с большим количеством блоков (>1000), измерение времени рендеринга, создания, удаления, перемещения блоков, тестирование операций с таблицами, списками, диаграммами, установка performance baselines и regression testing, автоматизация бенчмарков в CI/CD, сравнение с конкурентами (Notion, Obsidian, Roam Research)",
      "tags": [
        "производительность",
        "бенчмарки",
        "тестирование",
        "метрики",
        "regression testing",
        "CI/CD"
      ]
    },
    {
      "id": "044",
      "text": "Оптимизация перерисовки и рендеринга: оптимизация алгоритмов перерисовки в реальном времени для плавного UX, минимизация reflows и repaints через batching изменений DOM, использование Virtual DOM или аналогов для эффективного обновления, мемоизация компонентов для предотвращения лишних re-renders, debouncing и throttling для частых операций, requestAnimationFrame для плавных анимаций, CSS containment и will-change для оптимизации layout, измерение FPS и frame drops",
      "tags": [
        "производительность",
        "рендеринг",
        "перерисовка",
        "reflow",
        "repaint",
        "Virtual DOM",
        "мемоизация",
        "FPS",
        "оптимизация"
      ]
    },
    {
      "id": "045",
      "text": "Валидация входных данных",
      "tags": [
        "безопасность"
      ]
    },
    {
      "id": "046",
      "text": "Песочница для скриптов",
      "tags": [
        "безопасность"
      ]
    },
    {
      "id": "047",
      "text": "Обоснование изменений кода",
      "tags": [
        "документация"
      ]
    },
    {
      "id": "048",
      "text": "Структура конструктивной критики",
      "tags": [
        "критика"
      ]
    },
    {
      "id": "049",
      "text": "Цели рефакторинга",
      "tags": [
        "рефакторинг"
      ]
    },
    {
      "id": "050",
      "text": "Тестирование изменений: обязательная проверка всех изменений кода перед коммитом, запуск unit тестов после каждого изменения для проверки изолированных компонентов, интеграционные тесты для связанных компонентов и модулей, E2E тесты для критических пользовательских путей, проверка консоли браузера на ошибки и предупреждения после каждого изменения, валидация работоспособности функционала вручную, автоматические тесты в CI/CD пайплайне, проверка производительности при значительных изменениях, регрессионное тестирование для предотвращения поломки существующего функционала, использование pre-commit hooks для автоматической проверки перед коммитом, test coverage должен быть >80%, документирование результатов тестирования",
      "tags": [
        "тесты",
        "валидация",
        "CI/CD",
        "автоматизация",
        "качество",
        "регрессия",
        "coverage"
      ]
    },
    {
      "id": "051",
      "text": "Работоспособность на каждом шаге: инкрементальная разработка с проверкой работоспособности после каждого изменения, каждый коммит должен содержать работающий код без ошибок компиляции и runtime, система должна запускаться и функционировать после каждого шага разработки, избегание больших изменений без промежуточных проверок и коммитов, возможность отката к предыдущему работающему состоянию в любой момент, continuous integration для автоматической проверки работоспособности при каждом push, чек-лист проверки перед коммитом (код компилируется, тесты проходят, консоль чиста, функционал работает), atomic commits где каждый коммит представляет законченное логическое изменение, принцип никогда не коммитить неработающий код, разбиение больших задач на маленькие инкрементальные шаги с проверкой после каждого",
      "tags": [
        "инкрементальность",
        "atomic commits",
        "CI/CD",
        "работоспособность",
        "откат",
        "чек-лист"
      ]
    },
    {
      "id": "065",
      "text": "Иметь матрицу зависимостей между модулями, функциями и компонентами системы для анализа связанности",
      "tags": [
        "зависимости"
      ]
    },
    {
      "id": "066",
      "text": "Разделять модули на архитектурные слои (ядро, данные, UI, интеграция) с зависимостями только сверху вниз",
      "tags": [
        "слои"
      ]
    },
    {
      "id": "067",
      "text": "Отслеживать и исключать циклические зависимости между модулями: автоматическое обнаружение циклов через инструменты анализа (madge, dependency-cruiser, ESLint plugins), визуализация графа зависимостей для выявления циклов, рефакторинг архитектуры для разрыва циклических связей через dependency inversion и введение абстракций, проверка отсутствия циклов в CI/CD pipeline, документирование правил предотвращения циклических зависимостей",
      "tags": [
        "circular dependencies",
        "зависимости",
        "циклические зависимости"
      ]
    },
    {
      "id": "068",
      "text": "Выявлять критические модули (с большим количеством зависимых) для обеспечения их стабильности",
      "tags": [
        "критическое"
      ]
    },
    {
      "id": "069",
      "text": "Использовать диаграммы зависимостей (Mermaid/графы) для наглядного представления связей между модулями, функциями и архитектуры кода",
      "tags": [
        "визуализация"
      ]
    },
    {
      "id": "070",
      "text": "Выделять независимые модули (0 зависимостей) как стабильное ядро системы",
      "tags": [
        "ядро"
      ]
    },
    {
      "id": "071",
      "text": "API для программного создания, редактирования и интерактивной отрисовки блоков через скрипты: JavaScript API для создания блоков любого типа программно, методы для редактирования существующих блоков (изменение контента, стилей, атрибутов), интерактивная отрисовка блоков с live preview, поддержка пользовательских скриптов для автоматизации работы с блоками, event-driven архитектура для реакции на изменения блоков (onCreate, onUpdate, onDelete, onMove), hooks для расширения функциональности блоков, валидация и sanitization данных блоков, batch операции для массового создания/обновления блоков, undo/redo поддержка для программных изменений, документация API с примерами использования",
      "tags": [
        "API",
        "automation",
        "batch operations",
        "events",
        "hooks",
        "интерактивность",
        "скрипты"
      ]
    },
    {
      "id": "072",
      "text": "Поддержка композитных блоков (блок-контейнер для других блоков)",
      "tags": [
        "блоки"
      ]
    },
    {
      "id": "073",
      "text": "Система модальных окон и диалогов",
      "tags": [
        "UI"
      ]
    },
    {
      "id": "074",
      "text": "Lifecycle hooks для блоков (onCreate, onUpdate, onDestroy)",
      "tags": [
        "lifecycle"
      ]
    },
    {
      "id": "075",
      "text": "Event system для взаимодействия между блоками",
      "tags": [
        "события"
      ]
    },
    {
      "id": "076",
      "text": "Навигация и роутинг между вложенными страницами",
      "tags": [
        "навигация"
      ]
    },
    {
      "id": "081",
      "text": "Строить граф альтернативных решений и вариантов выбора",
      "tags": [
        "граф",
        "варианты"
      ]
    },
    {
      "id": "083",
      "text": "Валидация корректности решений",
      "tags": [
        "валидация"
      ]
    },
    {
      "id": "084",
      "text": "Система логирования событий и действий",
      "tags": [
        "логирование"
      ]
    },
    {
      "id": "087",
      "text": "Принцип DRY (Don't Repeat Yourself): избегать дублирования кода через переиспользование модулей, функций и компонентов, извлечение общей логики в utility functions, shared modules, composition patterns, HOC, mixins, создание библиотек переиспользуемых компонентов, применение паттернов проектирования для устранения повторений, рефакторинг дублирующегося кода в централизованные решения",
      "tags": [
        "DRY",
        "переиспользование",
        "utility functions",
        "shared modules",
        "composition",
        "HOC",
        "mixins",
        "рефакторинг",
        "дублирование"
      ]
    },
    {
      "id": "088",
      "text": "Структурированные рекомендации по улучшению",
      "tags": [
        "рекомендации"
      ]
    },
    {
      "id": "091",
      "text": "Детальный шаблон структуры функционала с обязательными и желательными секциями, шаблонами-образцами кода и автоматической валидацией",
      "tags": [
        "шаблон"
      ]
    },
    {
      "id": "092",
      "text": "Единая структура и архитектура: все модули следуют единым паттернам проектирования, структуре файлов, API-контрактам, обработке ошибок и документированы в централизованном источнике истины",
      "tags": [
        "единообразие"
      ]
    },
    {
      "id": "093",
      "text": "Соблюдать проектные стандарты: кодирования (ESLint/Prettier), документации (JSDoc), тестирования (AAA-паттерн), архитектуры (паттерны из централизованной документации)",
      "tags": [
        "стандарты"
      ]
    },
    {
      "id": "098",
      "text": "Расширенная автоматизированная отладка через Puppeteer + Chrome DevTools Protocol (CDP): программное управление браузером для воспроизведения ошибок, глубокая трассировка с перехватом всех событий (DOM mutations, Network requests/responses, Console logs/errors/warnings, JavaScript Exceptions, Performance events, Resource loading), запись сценариев действий пользователя, снятие скриншотов/видео при ошибках, профилирование CPU/памяти, coverage analysis, трассировка performance metrics, автоматическое создание регрессионных тестов на основе записанных сценариев",
      "tags": [
        "отладка",
        "автоматизация"
      ]
    },
    {
      "id": "099",
      "text": "Автоматическая генерация JSDoc-комментариев с типами, описаниями параметров, возвращаемых значений и примерами использования для всех публичных API, функций и модулей для поддержки IntelliSense/автодополнения в IDE и помощи ИИ-ассистенту в понимании кода: полная JSDoc документация с @param, @returns, @throws, @example, расширенные теги (@typedef, @callback, @template, @see, @deprecated, @since, @async, @generator), TypeScript интеграция с генерацией .d.ts файлов и проверкой типов, автоматизация через pre-commit hooks и валидацию корректности типов, автоматическое обновление JSDoc при изменении сигнатуры функции, генерация документации из JSDoc комментариев",
      "tags": [
        "JSDoc",
        "документация",
        "IntelliSense",
        "автодополнение",
        "TypeScript",
        ".d.ts",
        "типизация",
        "автоматизация",
        "IDE"
      ]
    },
    {
      "id": "100",
      "text": "Обеспечить единую структуру всей документации проекта: стандартные секции (Назначение, API, Параметры, Примеры, Зависимости, Troubleshooting), единый формат заголовков, кодовых блоков и ссылок, централизованное хранение шаблонов документации для консистентности и упрощения навигации",
      "tags": [
        "документация"
      ]
    },
    {
      "id": "103",
      "text": "Автоматически генерировать уникальные идентификаторы (MODULE_ID, FUNC_ID) в виде JSDoc-комментариев в начале каждого модуля и функции для упрощения отладки, навигации и работы ИИ-ассистента с кодом",
      "tags": [
        "ID",
        "автоматизация"
      ]
    },
    {
      "id": "106",
      "text": "Автоматическая валидация уникальности и корректности MODULE_ID, FUNC_ID при коммите с регенерацией дубликатов и несоответствий формату",
      "tags": [
        "валидация",
        "ID"
      ]
    },
    {
      "id": "107",
      "text": "Периодическая проверка наличия и уникальности data-атрибутов ID в DOM при запуске приложения с автоназначением недостающих",
      "tags": [
        "валидация",
        "ID"
      ]
    },
    {
      "id": "108",
      "text": "Валидация целостности UUID блоков пользователя и ссылок между ними при загрузке документа с восстановлением поврежденных связей",
      "tags": [
        "валидация",
        "блоки"
      ]
    },
    {
      "id": "110",
      "text": "Single Responsibility Principle (SRP): каждый модуль, класс или функция должны иметь только одну причину для изменения",
      "tags": [
        "SOLID",
        "SRP"
      ]
    },
    {
      "id": "111",
      "text": "Open/Closed Principle (OCP): модули должны быть открыты для расширения, но закрыты для модификации",
      "tags": [
        "SOLID",
        "OCP"
      ]
    },
    {
      "id": "112",
      "text": "Liskov Substitution Principle (LSP): объекты должны быть заменяемы экземплярами их подтипов без нарушения корректности программы",
      "tags": [
        "SOLID",
        "LSP"
      ]
    },
    {
      "id": "113",
      "text": "Interface Segregation Principle (ISP): клиенты не должны зависеть от интерфейсов, которые они не используют",
      "tags": [
        "SOLID",
        "ISP"
      ]
    },
    {
      "id": "114",
      "text": "Dependency Inversion Principle (DIP): модули верхнего уровня не должны зависеть от модулей нижнего уровня, оба должны зависеть от абстракций",
      "tags": [
        "SOLID",
        "DIP"
      ]
    },
    {
      "id": "115",
      "text": "Создавать диаграммы потока данных (DFD) для визуализации движения данных через систему: источники данных, процессы обработки, хранилища данных, потоки между компонентами, трансформации данных на каждом этапе",
      "tags": [
        "DFD",
        "визуализация",
        "данные"
      ]
    },
    {
      "id": "116",
      "text": "Документировать жизненный цикл данных: создание (источники, валидация), хранение (структура, формат, местоположение), обработка (трансформации, вычисления), использование (где и как используются), архивирование (условия, сроки), удаление (политики, безопасность)",
      "tags": [
        "данные",
        "документация",
        "lifecycle"
      ]
    },
    {
      "id": "117",
      "text": "Создавать визуализацию слоев архитектуры проекта (приложения): UI Layer (компоненты интерфейса), Business Logic Layer (бизнес-логика, правила), Data Layer (доступ к данным, репозитории), Core Layer (ядро, утилиты), с указанием границ ответственности каждого слоя и направления зависимостей (только сверху вниз)",
      "tags": [
        "архитектура",
        "визуализация",
        "слои"
      ]
    },
    {
      "id": "151",
      "text": "Руководство со всеми промптами: создание централизованного руководства со всеми промптами проекта, полный список промптов с описаниями и примерами использования, параметры и контекст применения каждого промпта, категоризация по типам задач (инициализация, разработка, код-ревью, рефакторинг, отладка), поиск и фильтрация промптов, версионирование промптов, best practices использования, шаблоны для создания новых промптов",
      "tags": [
        "документация",
        "промпты",
        "руководство"
      ]
    },
    {
      "id": "153",
      "text": "Промпт создания базовой системы: шаблон промпта для создания базовой архитектуры и структуры системы, определение требований и целей проекта, выбор технологического стека с обоснованием, проектирование архитектуры (модули, слои, компоненты, зависимости), создание структуры проекта (папки, файлы, конфигурация), настройка базовых инструментов (сборка, линтеры, форматтеры, тесты), документация архитектурных решений и принципов",
      "tags": [
        "промпты",
        "архитектура",
        "инициализация",
        "шаблон"
      ]
    },
    {
      "id": "154",
      "text": "Промпт инициализации проекта: шаблон промпта для полной инициализации нового проекта, создание репозитория и настройка git (gitignore, git hooks, branching strategy), инициализация package manager и зависимостей, настройка окружения разработки (IDE конфигурация, расширения, EditorConfig), настройка CI/CD пайплайнов (GitHub Actions, GitLab CI), создание базовой документации проекта (README, CONTRIBUTING, LICENSE, CODE_OF_CONDUCT), настройка команды и ролей, определение workflow разработки",
      "tags": [
        "промпты",
        "инициализация",
        "git",
        "CI/CD",
        "шаблон"
      ]
    },
    {
      "id": "155",
      "text": "Список обязательных обновлений и зависимостей в каждом промпте: требование включать в каждый промпт список файлов требующих обновления после изменений, зависимые модули и компоненты требующие проверки, документация требующая актуализации (README, API docs, комментарии), тесты требующие обновления или создания, конфигурационные файлы требующие изменений, changelog и версионирование, проверка обратной совместимости и влияния на другие части системы",
      "tags": [
        "промпты",
        "зависимости",
        "обновления",
        "чеклист"
      ]
    },
    {
      "id": "156",
      "text": "Предлагать варианты, вопросы, советы, решения, альтернативные пути: требование к ИИ предлагать множественные варианты решений с обоснованием плюсов и минусов каждого, задавать уточняющие вопросы для лучшего понимания контекста и требований, давать советы по улучшению кода и архитектуры, предлагать альтернативные пути реализации с разными trade-offs, анализировать компромиссы между подходами (производительность vs читаемость, простота vs гибкость), помогать в принятии обоснованных решений",
      "tags": [
        "варианты",
        "вопросы",
        "советы",
        "альтернативы"
      ]
    },
    {
      "id": "157",
      "text": "Исключение монолитности файлов: принцип разбиения кода на модули для предотвращения монолитных файлов, ограничение размера файла (рекомендуется до 500 строк кода), разделение ответственности по файлам (один файл - одна ответственность по SRP), выделение модулей, стилей, скриптов, изображений в отдельные файлы, рефакторинг больших файлов на более мелкие компоненты, улучшение читаемости и поддерживаемости через модульную структуру, упрощение навигации и понимания кода",
      "tags": [
        "модульность",
        "файлы",
        "разбиение",
        "500 строк"
      ]
    },
    {
      "id": "158",
      "text": "Оставлять комментарии в коде для нового функционала: требование добавлять комментарии при создании нового кода, комментарии в каждой функции с описанием назначения, параметров и возвращаемых значений, inline комментарии для сложной логики и неочевидных решений, объяснение алгоритмов и бизнес-логики, TODO комментарии для будущих улучшений и оптимизаций, комментарии с примерами использования, документирование edge cases и ограничений, объяснение причин выбора конкретного подхода",
      "tags": [
        "комментарии",
        "документация",
        "код"
      ]
    },
    {
      "id": "159",
      "text": "Структурированные данные в формате JSON для ИИ: требование подавать большие повторяющиеся структурированные данные нейросети в формате JSON вместо текстового описания, использование JSON для конфигураций, списков, таблиц, иерархических структур, улучшение точности парсинга ИИ через структурированный формат, снижение количества токенов через компактный формат, упрощение валидации и обработки данных, использование JSON Schema для типизации и валидации структуры",
      "tags": [
        "JSON",
        "данные",
        "формат",
        "структура"
      ]
    },
    {
      "id": "160",
      "text": "Указание точных имён и путей файлов в запросах к ИИ: требование указывать точные имена и абсолютные пути файлов в запросах к нейросети, явное указание файлов для чтения с полными путями, файлов для изменения с указанием конкретных строк и функций, файлов для создания с указанием директории, использование абсолютных путей вместо относительных для однозначности, предотвращение неоднозначности и ошибок при работе с файлами, улучшение точности работы ИИ через явное указание контекста",
      "tags": [
        "пути",
        "файлы",
        "промпты",
        "точность"
      ]
    },
    {
      "id": "161",
      "text": "Процесс разработки с управлением задачами (Kanban/Agile): организация процесса разработки через управление задачами с использованием Kanban/Agile методологии, ведение backlog с приоритизированными задачами и оценками, перемещение задач в статус in progress при начале работы с ограничением WIP (work in progress), отслеживание выполненных задач в done с критериями завершения, регулярные ревью и ретроспективы, визуализация процесса разработки через доски задач, метрики производительности (cycle time, lead time)",
      "tags": [
        "kanban",
        "agile",
        "задачи",
        "backlog"
      ]
    },
    {
      "id": "164",
      "text": "Комплексное руководство для разработчиков по полному циклу разработки: документ описывающий все этапы жизненного цикла разработки (планирование → проектирование → реализация → тестирование → деплой → поддержка), методологии разработки (Agile/Scrum/Kanban), роли и ответственность команды, процессы принятия архитектурных решений, определение критических компонентов (ядро, фундамент, несущие стены), best practices для каждого этапа, чеклисты и шаблоны для типовых задач, процессы код-ревью и тестирования, стратегии версионирования и релизов, процессы работы с ИИ-ассистентом на каждом этапе",
      "tags": [
        "руководство",
        "цикл разработки",
        "SDLC",
        "методологии",
        "best practices",
        "workflow",
        "документация"
      ]
    },
    {
      "id": "166",
      "text": "Валидация и проверка ответов ИИ-ассистента: обязательная проверка всех ответов и сгенерированного кода от ИИ перед применением, проверка корректности понимания задачи через уточняющие вопросы, валидация соответствия требованиям и контексту проекта, проверка на галлюцинации ИИ (несуществующие API, библиотеки, функции), тестирование сгенерированного кода (компиляция, запуск, unit тесты), проверка соответствия проектным стандартам, валидация безопасности кода, проверка производительности решения, код-ревью как обычного кода, документирование найденных ошибок ИИ, использование чек-листа проверки ответов ИИ",
      "tags": [
        "AI",
        "валидация",
        "галлюцинации",
        "код-ревью",
        "проверка",
        "тестирование"
      ]
    },
    {
      "id": "168",
      "text": "Контрастные примеры: правильный и неправильный подход с объяснением различий, последствий и причин выбора для обучения через anti-patterns и best practices",
      "tags": [
        "anti-patterns",
        "best practices",
        "контрастные примеры",
        "обучение",
        "правильно vs неправильно",
        "сравнение"
      ]
    },
    {
      "id": "169",
      "text": "Unit-архитектура: страницы/документы как независимые контейнеры с уникальным ID, заголовком, метаданными и упорядоченным списком блоков, поддерживающие вложенность страниц, навигацию и CRUD операции через API",
      "tags": [
        "Unit",
        "страницы",
        "документы",
        "контейнер",
        "иерархия",
        "навигация",
        "метаданные",
        "UNIT_ID"
      ]
    },
    {
      "id": "170",
      "text": "Генерация модулей и кода через шаблоны с автоматической валидацией соответствия критериям: использование code generators (Yeoman, Plop, Hygen) для создания модулей по шаблонам, шаблоны для типовых модулей (UI компоненты, API endpoints, тесты, документация), автоматическая валидация сгенерированного кода на соответствие критериям проекта (наличие MODULE_ID, JSDoc, тестов, обязательных секций), интеграция с критерием 091 (шаблон структуры функционала), генерация через ИИ с последующей валидацией, scaffolding инструменты для быстрого создания новых модулей",
      "tags": [
        "code generation",
        "scaffolding",
        "валидация",
        "генерация",
        "шаблоны"
      ]
    },
    {
      "id": "171",
      "text": "Построение диаграмм, стеков и порядков вызова функций через множественные инструменты: IntelliSense для автодополнения и навигации по вызовам с type hints, JSDoc для документирования call chains и генерации sequence diagrams, Puppeteer + CDP для динамической трассировки реальных вызовов и построения call stacks, DevTools для анализа Performance call tree и Memory allocations, автоматическая генерация диаграмм вызовов (Mermaid, PlantUML, Graphviz) через AST анализ, визуализация порядка выполнения функций с временными метриками, выявление критических путей и bottlenecks",
      "tags": [
        "AST",
        "CDP",
        "DevTools",
        "Graphviz",
        "IntelliSense",
        "JSDoc",
        "Mermaid",
        "PlantUML",
        "Puppeteer",
        "call graph",
        "call hierarchy",
        "call stack",
        "sequence diagram",
        "визуализация",
        "диаграммы",
        "критические пути",
        "навигация",
        "отладка",
        "порядок вызовов",
        "стек вызовов",
        "трассировка"
      ]
    },
    {
      "id": "172",
      "text": "Масштабируемость и производительность для больших объемов данных: обеспечение стабильной работы при 10,000+ страниц и 100,000+ блоков через ленивую загрузку контента (lazy loading), виртуализацию списков (virtual scrolling) для рендеринга только видимых элементов, pagination и infinite scroll для постепенной загрузки данных, code splitting и tree shaking для оптимизации bundle size, performance budgets и мониторинг метрик (FCP, LCP, TTI, TBT), кэширование стратегии (memory cache, disk cache, service workers), оптимизация критических путей рендеринга",
      "tags": [
        "масштабируемость",
        "производительность",
        "lazy loading",
        "виртуализация",
        "virtual scrolling",
        "pagination",
        "infinite scroll",
        "code splitting",
        "performance budget",
        "кэширование"
      ]
    },
    {
      "id": "173",
      "text": "Индексация и полнотекстовый поиск в больших объемах данных: реализация full-text search для быстрого поиска по 10,000+ страниц и 100,000+ блоков через search indexes (Lunr.js, FlexSearch, MiniSearch, Fuse.js), инкрементальная индексация при создании/изменении контента, поддержка сложных запросов (AND, OR, NOT, фразовый поиск, wildcard), фильтрация и сортировка результатов по релевантности, кэширование результатов поиска, fuzzy search для опечаток, highlighting найденных фрагментов, search suggestions и autocomplete",
      "tags": [
        "индексация",
        "поиск",
        "full-text search",
        "search index",
        "Lunr.js",
        "FlexSearch",
        "фильтрация",
        "сортировка",
        "fuzzy search",
        "autocomplete"
      ]
    },
    {
      "id": "175",
      "text": "Система экспорта и интероперабельности: экспорт контента в множественные форматы (Markdown с сохранением структуры и метаданных, PDF с настройкой стилей и layout, HTML с CSS и интерактивностью, OPML для outline processors, JSON для программного доступа, DOCX для Microsoft Word, LaTeX для научных публикаций), импорт из других систем (Notion, Obsidian, Roam Research, Evernote, OneNote, Google Docs, Confluence), поддержка стандартов разметки (Logseq Markdown с block references, Obsidian Markdown с wikilinks и frontmatter, Org-mode для Emacs, CommonMark, GitHub Flavored Markdown), сохранение связей между блоками при экспорте/импорте, пакетный экспорт множества страниц, автоматическая конвертация форматов, preview перед экспортом, настройка параметров экспорта (включение/исключение метаданных, изображений, вложений), экспорт в архивы (ZIP с полной структурой проекта), API для программного экспорта/импорта, миграционные инструменты с mapping полей",
      "tags": [
        "API",
        "CommonMark",
        "Confluence",
        "DOCX",
        "Evernote",
        "GitHub Flavored Markdown",
        "Google Docs",
        "HTML",
        "JSON",
        "LaTeX",
        "Logseq",
        "Markdown",
        "Notion",
        "OPML",
        "Obsidian",
        "OneNote",
        "Org-mode",
        "PDF",
        "Roam Research",
        "ZIP",
        "block references",
        "frontmatter",
        "wikilinks",
        "архивы",
        "импорт",
        "интероперабельность",
        "конвертация",
        "миграция",
        "экспорт"
      ]
    },
    {
      "id": "177",
      "text": "Многопоточность и устойчивость к высоким нагрузкам: использование Web Workers для параллельного выполнения тяжелых вычислений (парсинг больших документов, индексация для поиска, обработка изображений, сложные вычисления) вне main thread для сохранения отзывчивости UI, SharedArrayBuffer для обмена данными между потоками без копирования, worker pools для переиспользования workers и управления их количеством, offscreen canvas в workers для рендеринга графики, graceful degradation при недоступности workers, rate limiting и throttling для предотвращения перегрузки (ограничение частоты запросов, debouncing пользовательского ввода, queue management для задач), circuit breaker pattern для защиты от каскадных сбоев, backpressure механизмы для контроля потока данных, connection pooling для эффективного использования ресурсов, load balancing между серверами/workers, auto-scaling при увеличении нагрузки, health checks и мониторинг состояния системы, error recovery с автоматическими retry и exponential backoff, timeout management для предотвращения зависаний",
      "tags": [
        "Web Workers",
        "SharedArrayBuffer",
        "worker pools",
        "offscreen canvas",
        "многопоточность",
        "параллелизм",
        "rate limiting",
        "throttling",
        "circuit breaker",
        "backpressure",
        "load balancing",
        "auto-scaling",
        "устойчивость",
        "нагрузка",
        "resilience"
      ]
    },
    {
      "id": "178",
      "text": "Multiplayer-коллаборация в реальном времени: одновременное редактирование документов несколькими пользователями с отображением курсоров и выделений других участников, система комментариев с @-упоминаниями и уведомлениями, гранулярные разрешения на уровне блоков и страниц (просмотр, комментирование, редактирование), conflict resolution при одновременном редактировании одного элемента, presence indicators (кто онлайн), история изменений с авторством, live cursors с именами пользователей и цветовым кодированием",
      "tags": [
        "UI",
        "WebRTC",
        "WebSocket",
        "collaboration",
        "comments",
        "conflict resolution",
        "cursors",
        "mentions",
        "multiplayer",
        "permissions",
        "presence",
        "real-time",
        "авторство",
        "коллаборация",
        "комментарии",
        "курсоры",
        "разрешения",
        "уведомления"
      ]
    },
    {
      "id": "179",
      "text": "Встроенная AI-интеграция для пользователей редактора: AI-ассистент для генерации, редактирования и улучшения контента (текст, таблицы, диаграммы, код), автоматический рефакторинг и улучшение написанного, автосвязи между блоками на основе семантического анализа, автотеги и категоризация контента, чат с собственной базой знаний (RAG) для поиска и ответов на вопросы, поддержка множественных AI-провайдеров (OpenAI, Anthropic, Google, локальные модели), интеграция локальных моделей (Ollama, LM Studio, LocalAI) через плагины, настраиваемые AI-команды и промпты, контекстные AI-предложения, summarization длинных документов",
      "tags": [
        "AI",
        "AI-генерация",
        "Anthropic",
        "Claude",
        "GPT",
        "LM Studio",
        "LocalAI",
        "NLP",
        "Ollama",
        "OpenAI",
        "RAG",
        "UI",
        "autocomplete",
        "автокатегоризация",
        "автосвязи",
        "автотеги",
        "генерация контента",
        "локальные модели",
        "плагины",
        "рефакторинг",
        "семантический анализ",
        "чат с базой знаний"
      ]
    },
    {
      "id": "182",
      "text": "Принцип минимизации зависимостей между модулями через абстракции, интерфейсы, dependency injection, event-driven архитектуру. Модули взаимодействуют через контракты, а не конкретные реализации. Паттерны: Observer, Mediator, DI, Service Locator, Event Bus",
      "tags": [
        "Event Bus",
        "Mediator",
        "Observer",
        "Service Locator",
        "dependency injection",
        "event-driven",
        "interfaces",
        "loose coupling",
        "message bus"
      ]
    },
    {
      "id": "183",
      "text": "Единая система для создания, управления и визуализации стратегического плана развития проекта с интеграцией всех типов диаграмм Mermaid. Полная картина архитектурных решений, временных рамок, зависимостей между модулями и приоритизации задач",
      "tags": [
        "Gantt",
        "KPI",
        "Mermaid",
        "mindmap",
        "roadmap"
      ]
    }
  ]
}
